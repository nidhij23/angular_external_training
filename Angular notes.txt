////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

paste.ubuntu.com--> is a good website for sharig code on the go

Google Search the below(Self Study)
Day1-->
	ReactiveX

Day2-->
	Another good book for design patterns is HeadFirst Design patterns
	LEarn ABout Javascript Modules--Google--https://addyosmani.com/resources/essentialjsdesignpatterns/book/-->
	RequireJS,CommonJS,

	how to prevent augmentation of object in javascript?Object sealing 
	how to delete properties and how to iterate properties in Javascript
	Hoisting

Day3-->
	npmjs.com(learning how to crate a node module)
	versioning syntax in case of dependencies(usage of ^,~,- )
	meaning of '@' barrel in node system
	sourceMapJS
	SystemJS
	Webworker--library for implementing multi threading in JS(used in progressive web apps)

Day4-->
	Simple Change API

Day5-->
	EventEmitter
	Custom Pipes
	Chai.Js
	Mocha.js
	QueryParams
	CSS 3 Animations
	AuthGuard
	Arrays API-->some functions-->map,find,filter,...

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////Some topics not clear/////////////////////////////

Linking loading
Lexical analysis in terms of Javascript and the tree structure formed


///////////////////////////////////////////////////////////////////////
Angular 2
means angular brackets <>

Angular can augment HTML

Javascript parts:
1.Language fundamentals -type,variables,operators,contstr,loops
2.Functions -expressions,callbacks,closures
3.OO -objects
4.UI programming/DOM
5.Socket Programming -Ajax

Client
1.Language fundamentals -type,variables,operators,contstr,loops
2.Functions -expressions,callbacks,closures
3.OO -objects

4.DOM
5.AJAx


Server
1.Language fundamentals -type,variables,operators,contstr,loops
2.Functions -expressions,callbacks,closures
3.OO -objects


////////////////////////////////////////////////////////////////////////////////////////////////////
DOM is DOcument Object Model
DOM is spec from w3c
Spec says how to rpresent html program(source code)/passive into active program

Spec recommends runtime representation must be a datastructure "tree"

Javascript has 3 built-in objects:
1.Plain Objects
2.Objects
3.Wrapper classes -String,Number,Boolean,Function
Example-Math,Date,Regex,JSON


DOM Objects -window,document,location,history,forms,links,any UI element(p,h1,span,div)

window-->variable--function Window(){}
document-->variable-- HTMLDocument

window-->represents Browser
document-anything inside body tag

location-which browser location-->angular2 core object to implement navigation  and routing,/spa(single page applications)
forms


///////////////////////////////////////////////////////////////////////////////////////////////////////////


Javascript DOM API

Event programming

Type of DOM nodes:
1.element node
2.attribute node <a href="abc"> "href" is attribute
3.Text node/content node <li>test</li> "li" is text node
4.Comment node

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DOM Wrappers/libs/frameworks
 jQuery Angular React ember Polymer all sit on DOM 

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Typescript :
	--superset of Javascript
	--typescript scales Javascript
-Modularity
-Object Oriented
-IOC
-static type system

installing it using node.js-->npm install -g typescript
						   -->named as hello.ts

run in browsers by--->hello.ts--hello.js--run in browser

Core Feature of typescript -->type+script

Variable declaration in Typescript
In ES 6 ,dont use var keyword
let,const





Java Packages
Js does not have Modules

Module design patterns/Module Loaders
Module design specs:
1.AMD -->Asynchronous module definition
2.CommonJS --> Requires JS used to load the modules and it is used for dependency management...COmmonJS has been deprecated
3.ES 6 Modules
4.UMD-Angular 2


app.js
For using other js files use requires-->var myfile=require('one');
For exporting the modules use export

ES 6 modules=Best Pratices from AMD +Best Practices CommonJS

one.js-->export class sayHello{}
app.js -->import {sayHello} from 'one';

All the files are linked by "Class Loader" in java
In javascript this work is done by 'Module loader'

Module loaders:
Webpack
SystemJS


/////////////////////////////////
While lexical analysis-the lexical anyalser copies the code once again and places the code in block one line above which is called as --> Hoisting
java supoorts block level scope so this problem doen not occur but in js it occurs

in ES 5: this can be prevented by
IFFE functions -->an immediately invoked function expression(or IIFE,prononce as "iffy" ) is a javascript programming lanaguage idiom which producess a lexical scope using Javasript's function scoping

use let inplace of var inside functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////

Angular is famous because:
1.Angular is DOM framework based on MVC Design framework
2.Angular is helping to build DOM in modular way
3.Angular use IOC design pattern
4.Angular offers declarative DOM programming
5.Angualr is SPA framework
6.Angular is good for CRUD applications

Angular versions:
Angular 1 --> written in es 5 standard
Angular 2 --> written in es 6,typescript,Dart standard
		Uses Typescript
		Component-driven architecture


Angular architecture
1.Used to build web application
	Types of web application
	1.Action Based 
	2.Resource based--Webservice
	3.SPA based-Angular,React js,Ember,Polymer 

	Application:collection of objects+static assets(css,htmls,images,audio,video,docs)

	Collection of objects--->Entity,Bean,POJO
	Component-->Collection of objects

Angular application-->collectionof objects+static assets
Component : is an object.
This terminology termed by Microsoft in in 1990s.
	1.Which must represent "UI element"-button,textbox,window,dialog
	2.could be reused

Module :is an Object
Service: is an Object

application={component,module,service}

Parts of component :
	--Simple object becomes a component on adding a decorator(called annotation in java)

	Component=Object+UI(html element)

	Template:collection of static +dynamic expression

	Client side templating  system:
	1.Mustachejs-{{}}
	2.Handlebars.js
	3.Jade
	4.EJS
	5.DustJS-linked in uses this
	6.jQuery Templates (not popular)

	Template Syntax:
	<h1>Hello {{name}} </h1>

	data+<h1>Hello {{name}}===view

	component=data+Template
	@Component
	class HeroComponent{
		title:string='Tour Of Heroes';

	}

-->@Component is a function inside a class and is to be imported by --> import{Component} from '@angular/core


{}-->Component configuration object

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Angular 2 programming

1.use angular seed to scaffold the project 
 //another site called as yeoman can be used for scaffolding the seeds of all projects


to start a module in node--
>npm init-->to start a mdoule in nodejs which will create package.JSON which is mandatory to start
>package.JSON--> is the configuration file in node modules similar to pom.xml
			JSON structure:
			JSON is a string file/text file
			JSON is created from Javascript object literal pattern
			JSon was created to transfer data between  2 different applications

			->JSON is popular because it is very lightweight as it does not contain any grammar
			-->Json must have only literal-->string,number,boolean,object,array
			-->JSON keys are string and it has to mentioned specifically in double quotes to ensure its compatibility with all programming languages
			example:
			{
				"name":"Nidhi",
				"working":true
			}			
			JSon can be string literals as well as objects(nested JSON)

	Structure of package.json--
		"name": "angular-quickstart", -->name of project into whihc the project is build
		 "version": "1.0.0", -->version of your own project

		 to install lite server 
		 		npm install lite-server	-g
				 Running server
				 	1.direct 
					 	>lite-server
					2.thorugh node
						>npm init>
						>package.json
							"scripts":{
								"start":"lite-server"
							}
		Scripts-->automating
		 "start": "concurrently \"npm run build:watch\" \"npm run serve\"",
		 	here concurrently is a library-->concurrently.js
			 this will help in running 2 commands together
			 	the 2 commands here are npm run build:watch\ && npm run serve\
				 	these 2 commands run 2 scripts
					 "build:watch": "tsc -p src/ -w",&&  -->this command is watching file changes in the given location
					 "serve": "lite-server -c=bs-config.json", -->this command is starting lite-server with its configuration (-c=bs-config.json)

		"keywords": [],-->this is for Search Engine optimisation
		"dependencies":{} -->these are the modules to be downloaded in the form of dependencies
				!!-- @ is know as barrel in node and it has a special meaning --!!
		"devDependencies": {} -->these are dependencies needed only during development
			while installing the packages mention --save to also update the package.json with the new dependency

		For testing the application-->npm test'
		
		tsconfig.json file -->an important file -->soul of typescript compilation--configuration for tsc compiler
			parts of tsconfig.json:
				CommonJS,target is es5(being downgraded),sourceMap (is a JS library for debugging purpose)
				lib is es2015
		
		Loader-->SystemJS is for loading 
		Flow of Angular-app/Booting of angular app
			--index.html
				polyfill-terminology mentioning new features for older browsers.example-
							css3 - animation would not run in IE 3 or IE 4,there comes the role of pollyfill libraries
							similarly in case of  ->angular features would be available to older browsers using the below libraries:
									<script src="node_modules/core-js/client/shim.min.js"></script>--Polyfill

				<script src="node_modules/zone.js/dist/zone.js"></script> -->for providing angular runtime
    			<script src="node_modules/systemjs/dist/system.src.js"></script> -->for implementing loaders
				<script src="systemjs.config.js"></script>-->configuration for system loaders
				<script>
						this is for kickstarting boot process
      					System.import('main.js').catch(function(err){ console.error(err); });
    			
				</script>

				Flow starts from --> index.html:
				-->first polyfill occurs
				-->then zone.js provides runtime environment
				-->then loader loads the files 
				-->then main.js kickstarts the process 
				-->in main.js there is a bootstrap module which starts appModule(which is Root Module)
				-->this Root Module boostraps the AppComponent which is the RootComponent which after words can contain other components

		Modules:
			Module is object which contains other objects(components,pipes,modules,services,directives,...)
			Equal to packages in java

			@NgModule({})			{} here this is module configuration object
			class AppModule{}  --Normal classes become module by decorating it with @NgModule

			@Component({})			{} here this is object(component confguration object)
			class AppComponent{} --Normal classes become component by decorating it with @Component

			export class AppComponent{}
			let component=new AppComponent();
			-->Angular in DI(Dependency Injection)/IOC(Inversion of Control) framework.

			Inversion of Control..
				class Address{}
				class Employee{
						Address address;
						//setter and getter
						//constructor
				}
				Address addr=new Address();
				Employee emp=new Employee(addr);//constructor Injection
			
			app.module.ts
				@NgModule({
  					imports:      [ BrowserModule ], //here AppModule is root Module and BrowserModule is the subModule
 					declarations: [ AppComponent ],
 					bootstrap:    [ AppComponent ]
				})
				>imports:  --> specify module dependencies
					Angular DI does not follow getter/setter functions as in Java,it rather uses constructor functions
				>declarations:Components are added in declarations
				>bootstrap:root component of this module
				>providers:for importing services(this is an optional one used when services are used)

			app.component.ts 
				import { Component } from '@angular/core';
																//this whole is passive code
				@Component({
  					selector: 'my-app',
  					template: `<h1>Hello {{name}}</h1>`,   //MVC-->Model ->name,View-template,Controller-component class
				})
				export class AppComponent  { name = 'Angular'; }
				
				The active code is <my-app></my-app>

				Angular started with the philosophy of HTML5 custom tags-->
					 HTML5 spec says existing html tags can be modified and new attributes can be added to these
				ADT(Abstract data theory)-making custom from primitive
					class Employee{int,float,char,boolean}
					Employee = {int,float,char,boolean}
					<my-app></my-app> = {h1}

				//MVC-->Model ->name,View-template,Controller-component class
				
			Templates:
				Binding
				  ->moving data from controller to view
				  ->moving data from view to controller
				  Types of Binding:
				  	1.Interpolation		{{}}
					2.Property Binding []
					3.Event Binding ()
					4.Attribute Binding []
					5.Class Binding []
					6.Style Binding []
					7.Two-way data binding with ngModel [()] (banana in a box)
					
					Interpolation-->moving data from controller to template
					
					Property Binding-->passing data to the component via props or attributes(dynamically)
					<my-app>
						<greet [message]="welcome"></greet>		// message - property name
						<greet [message]="hello"></greet>
					</my-app>

					Event Binding-->
						in HTML every element is object(DOM object)
						Object =data+methods
						DOM Object=variables+methods
								methods=normal methods/events

						//pattern1 :inline event attachment		
						<button onclick="listener"></button> 
						//pattern2 :
						<button id="save"></button>
						document.getElementbyId("save").addEventListener('click',cb);
							How does JS differentiate between nprmal method and event?
								->Event method starts with "on" example-->"onClick",onKeyPress,onMouseMove
						In Angular:
						<button (click)="listener()"></button>  //

					Two-way data binding-->[()] property binding+event binding
						<input text="text" onKeyPress="test()">
						test(){
							console.log(txt.value);
						}
						Angular offers ngModel -object which can catch data
							[(ngModel)]-need not write any event
							<input type="text" [(ngModel)]="name">
							!!!!--let ngModel={name:"Nidhi"}--!!!!

					View: dynamic html
						Create:
							Elements-->h1,h2,p,
							Layout elements --> div,ul,li,span,list,table
							Layout types --> Grid Layout(using table),Card Layout(using div),ListView(using ul)

			Directives: Angular has directives for DOM manipulation:
				3 types:
					1.Component directive --> A directive associated with template (selector-key is name of directive)tag for component
					2.Structural directive -->change the DOM layout by adding or removing DOM elements--> *ngFor,*ngIf,*ngSwitch * used to differentiate
					3.Attribute	directive -->Change the appearance or behaviour of elements 
						<li tooltip="test></li>
						@Directive({selector:'tooltip})
						class ToolTip{}
					
					Styling your list view
					1.through style element in index.html
					2.component has property 
						styles:[]-inline
						stylesUrl:[] external

				//to access a variable from controllrt to template it must be instance variable/declared at class level

					Implementing 2-way data binding
						1.you have to import forms module in appModule
						2.use ngModel
					
					<input (keyup)="selectName(ngModel)="name">
					<input (keyup)="selectAddress(ngModel)="test">
					getData(data){}
						let ngModel="{
							name:'test',
							age:30
						}
					  Observable design pattern --> 
					  keyUp(value) newValue-->keyUp(value){selectedTrainer.name=value}-->Broadcast the changes in "name"
					  	-->Event Emission-->

			//changes styles dynamically
			Class Binding--> 2 classes selected unselected
			<h1 class="selected">test</h1> 
				[class.selected]="trainer===selectedTrainer" //true
					|	 |						|
				 class  name of css class 	   when

			Property BInding-->Property binding will help to transferdata from parent to child coomponent 
				Single direction flow-Passing data down to child components (This concept from ReactJS)

				template:
				<my-app>
					<trainer [trainerInfo]="trainers" [title]="'MyTrainerApplication'">
						<trainer-details>
							<trainer-clients></trainer-clients>
						</trainer-details>
					<trainer>
					<student [studentInfo]="students">
						<student-details>
						</student-details>
					</student>
				</my-app>

				@Component({selector:'trainer'})
				export class TrainerComponent{
					trainers=TRAINERS;
				}

				@Component({selector:'trainer-details'
				template:`div><span>{{trainer.name}}</div></span>
				})
				export class TrainerDetailsComponent{
					@Input('trainerInfo')my_trainers;
				}
				//this is called as data attribute
				
				--Service Layer
					template-view--->controller component-->service Layer-->Server(though ajax)
					->simple typescript class
					export class TrainerService{

					}
				2 types of services:
					shared services: Service is injected/create at module level
					local component/component level service: Service is created at component level

					Asynchronous Programming:
						Fundamental concept behind http-->Client can read/write--->Server can read /write
							http -->is a protocol-->http.c progam-->works as Input/output
							client server communicate based on http
						We have es6 Promise Class to manage asyn programming flow
							let promise=new Promise(); //design pattern
						Promise API
							resolve is a function--success
							let resolve =(response)=>{}
							let reject=(err)=>{}  //err and reject can be any variable name
							let promise=new Promise(resolve,reject);

							function Promise(resolve,reject){  //this is how promise is implemented internally
								if(statuscode==200)	resolve();
								if(statuscode=500) reject();
							}
							promise.then(function(data){},function(err){})
						HTTP
							Ajax->Asynchronous Javascript.Synonyms of Ajax:
								XHR->XML Http request
								HTTP Client

							AJAX Object/XHR Object = Socket
							Angular HTTP Wrapper is built on XML HTTP Request

								Angular 2 offers http wrapper as Separate module
								->that module contains HttpService-Object which handles client server communication

								HttpService has methods:
								1.get	------read
								2.post  ------sending for insert
								3.put   ------sending for update
								4.delete -----sending data for delete

								httpService.get();
								httpService.post();
								httpService.put();
								httpService.delete();

								return type of all http service methods is Observable(Reactive Programming)
								REactive programming is a programming methodolgy to make your application 100% event driven
								Implementation:
									1.Server Layer - Web Service layer
										In angular we can create fake/mock web service
									2.Inject/Create web service inside Root Module-Not required if you access external web service 
									3.DI Injection - InMemoryWebApiModule.forRoot(InMemoryDataService)//this is another way of injecting service
									4.Service Layer - Access HTTP Object in service layer
										(i) Import HTTP service 
										(ii) 

										//the standard format of response received
										response={
											headers:[
												content-type:'application/json,
												server:'apache'
											]
											data:[
												{
													id:1,
													name:'Nidhi'
												}
											]
										}

										return this.http.get(this.url)
        									.toPromise()
        									.then(response => response.json().data as Trainer[])
        									.catch(err => err);

											the and catch are 2 important API's of promise..the result of this http .get is an Observable
											we convert that response into Promise and once the promise is resolvde then the data property is picked from the response
											and then the put into the Trainers[] array which is returned by the promise and in case any error occurs then the catch 
											part would be executed

						Event
						1.event object
							 <input type="button" id="mybtn" value="click">
							  document.getElementbyId('id1').addEventListener('click',
								  function(event){});
									  event is a variable which can be anything
									  event variable points to "Event" Object
									  -->Event object has a lot of property,using the property we can control key build
									  	<button (click)="doStuff($event)">Click</button>
										  doStuff(evt){
											  console.log(evt);
										  }
										Hierarchy of Mouse Event Object :
										Object->Event->UI Event->Mouse Event(can be seen in proto_ while printing event )

											 this.values = (<HTMLInputElement>event.target).value
											 	in this target is property of event object
												 		value is also property of event object

										Template Reference variable:
							Key event filtering(with key.enter)
								The (keyup) event handler hears every keystroke
								
								 examine $event.keyCode 
								 in Angular 2 keyup.enter is used specifically for enter
							HOT Keys: keyup.which
						
						Angular Component LifeCycle
							component life hooks(methods)
							lifecycle implemented through interfaces
							5 phases of component lifecycle:
								1.constructor - For object initialisation
								2.ngOnChanges - For Property initialisation (called whenever a compoenet receives new property)
								3.ngOnInit - For Component Initialisation  (called only once for compoenent initialisation)
									used for initial data setup/data services injection should be done in ngInit
								4.ngDoCheck - Change Detection Life Cycle (Whenever component is changed,this life cycle is called)
								5.ngAfterViewInit
								6.ngAfterViewChecked
					How lifecycle Hooks work:
						1.constructor is called
							constructor-service layer-di injection only
						2.property listener
						 	<trainer-details [name]="value">
							 ///////////////Interface called as simple change fo capturing new and old value//////////////
						3.init 
							Listener is called when component is initialised
							It is used for initial data set
						4.contentchanged-capture all changes being done in the component
						5.Child	
							ViewInit -Child	
							@ViewChild for making the parent watch the changes of child-Decorator will help 
								to access Child component data from Parent
								->@ViewChild(ChildViewComponent) viewChild: ChildViewComponent;

							Event Emitter-->$event emitter must be passed

							@Output() onIncrement=new EventEmitter<number>;

							Pipes-->used for tansforming data.For ex-
							parameterising a pipe:
							a pipe can accept any number of optional paramteres to fine-tune the output.
							Built-in Pipes:
								DatePipe,UpperCasePipe,LowerCasePipe,CurrencyPipe and percentPipe
							Parameterising a pipe:

							import{Pipe,PipeTransform} from '@angular/core';
								Pipe and PipeTransform must be imported and these are to be injected in the declarations section
							@Pipe({
								name:'exponentialStrength'
								})

								export class ExponentialStrength implements PipeTransform{
									transform(value:number,exponent:string):number{
										let exp=parseFloat(exponent);
										return Math.pow(value,isNaN(exp)?1:exp);
									}
								}

								value|exponentialStrength:paramter
								10|exponentialStrength:2

								Web Accessibility:
									ARIA-defined ways to make Web content 
										-->https://www.w3.org/TR/wai-aria/
									    <input type="text" value="3" size="2" id="numTimes" aria-label="Number of times to flash screen">
										
										[attr.aria-label] is to used instead of pure aria labels//attr is a DOM property
										
										HTML 5 audio:

			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			Testing:
				Unit testing
				Functional Testing-->Selenium
				Load Testing-->Soap UI,Jmeter
				UI Testing-

				Protractor,Nodemon,TCP Monitor -->Tools for testing
				JAsmine-programming interface for testing pure JS applications/Jasmine core library has been taken from Chai
				natural way of testing-->BDT(Behaviour driven Testing)
				Chai.js	
					expect.js
					should.js
					Assertion library-->verifies whether req==output

					Chai-->assertion library
					Jasmine JS-->

					//test environment

					suites:a Test suite begins with a call to the global Jasmine function describe with 2 parameters:a string and a function
						suite is collection test
						describe(namofthesuite,cb)
						describe(nameofthesuite,cb)
					spec:defined by calling the global Jasmin function it,whihc like describe takes a string and a function .
					THe string is the title of the spec  and the function is the spec

					describe('herocomponentsuite',function(){
						describe('login sub suite',function(){
							it('user must have 7 characters',function(){
								assertionLogic
							})
							it('usr pass',function(){

							})
						})
						describe('logout sub suite,function(){
							it('user must be logedout',function(){

							})
						})
					})
					//these functions are from Mocha
					suite can have sub-suites
				Hooks-life cycle API's
					Life cycle API's are called before and after "it"-->before,After,
					before(function(){
						//run before all tests in the block
					})
					after(function(){
						//run after all tests in the block
					})
					beforeEach(function(){
						//run before each tests in the block
					})
					afterEach(function(){
						//run after each tests in the block
					})
				Assertion Section-->
					Assertion library/Expectations
					Expectations:
						A spec contains one or more expectations that test the state of the code.
						An expectation in JAsmine is an assertion that is eithr true or false
						Expectatiotn are built with the function except which take a avlue,clled teh actual.
						It is chained with with a maTcher function

						describe("A Suite",function(){
							if("contains spec withan expecting",function(){
								expect(true).toBe(true);
							})
						})

					Testing a component:
					1.Isolated Test:Isolated unit test examine an instance of a class all by itself without any dependence on Angular
						or any injected value
					2.Angular Test Utility Classes:Testing component where Component has dependency

					In Angular 2 ,TestBed object has been given to check 
					TestBed class and several helper functions from @angular/core/testing library
					1.TestBed:
						Creates Testing Module Object
						Creates Testing Component Object

					2.TestFixture
						Preparation of input data and stup/creation of fake or mock objects.Lodaing a database with a specific,
						known set of data
						
						ComponentFixture: a handle on th etest environment surrounding the created compoent.the Refernce of the component
							is Test Env.The fixture provides access to teh compoent itself and to theDebugElement.
							ComponentFixture will have reference of ORiginal COmpoent Reference

						DebugELement: which is a handle on the component's DOM Element.

						MethodQuery:The query method takes a predicate function and searches the fixture's entire DOM tree for thefirst element 
							that satisfies the predicate

						  TestBed.configureTestingModule //here we are creating a module

						  Change Detection Algorithms:
						  	fixture.detectChanges() //on component you are calling detectChanges
						  	Webworker-javascript implementation of Multi Threading
							  detectChanges function called the DoCheck method

					Testing Service:
						original service should not be used
						It needs to be mocked
						Mocking:
							TestBed.configureTestinModule({
								declarations:[WelcomeComponent],
								//providers: [Userservice]//not to use here
								providers: [{provide:Uservice,useValue:userServiceStub}]
							});
						Access Stub:
								userService=TestBed.get(UserService);

					Protractor is an end-to-end functional testing tool for angular JS applications.It'll do things like push buttons ,
						enter input and otherwise drive your application and then test the output that is produced from that input.

						Protractor is wrapper for selenium WEbDriver.Protractor adds some specific Angular js functionalities to Selenium WebDriver
						
						//Groovy is good for testing(functional testing)

		    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			Routing and Navigation:
				SPA->Single page applications

				The Angular Router enables navigatin from one view to the next as users perform application tasks.
					The Basics:
					<base href>
					Router imports
					Configuration
					Router Outlet
					ROuter links
					Router State

				Types->Simple Routing,
					   Modular Routing,
					   Multi-view design with child routes
					   Routing works on Hyperlinks only
				Basic Concepts:
				1.<base href="> in index.html file
				2.imports (routerModule and routes )are imported
				3.configuration
				
				Path
				2 variety of syntax for defining path:
					1.static path: path witha pathname
						path:component,
						static+dynamic path:							
							path:component/:id-->hero/1,hero/2
					2.empty path :if no path match found,redirect to a particular component as heroes here
							path:''
							redirectTo:'heroes'
							pathMatch:'full'   'dashboard/heroes'
												'heroapp/heroes'
												'/heroes'
					3.wildcard: '**' This route will be selected if none of the above path matches
						The order of routes matters.Recommended Design:Static route-->Empty-->Wildcard
						the router uses a first-match wins strategy when matching routes.
					
					Data property:data propertyis accessible within each activated route.Used to store items such as page titles,bredcrumb text

				4.RouterOutlet:is a plaeholder that nagular fills dynamically based on the current routes
					<router-outlet></router-outlet>
					<router-outlet name="left"></router-outlet>
					<router-outlet name="right"></router-outlet>
				5.RouterLinks :lets you link to specific parts of your app
					[{path:'user/:name',component:UserCmp}]

					when linking to this route 
					<a routerLink='user/bob'>link to user component</a>

					touterlink can take queryParams(after ?):
					<a [routerLink]="['/user/bob']" [queryParams]="{debug:true}" fragment="education">
					
					RouterLink will use this to generate :
						link: /user/bob#education?debug=true
						<a routerLink="/crisis-center" routerLinkActive="true">Crisis center</a>
						<router-outlet></router-outlet>
						routerLinkActive :this will tell which route is active
						QueryParams:-> http://www.example.com/login.jsp?sessionId=9999

					ActivatedRoute:a service that is provided to each route component that contains route specific information 
					such as route parameters,static data,resolve data,global query params,and the global fragment					
				6.Router State:

				Lazy Loading : 
				Eager Loading :

				For Programmatic navigation->Router object is to be used(that is based on conditions)
					this.router.navigate('../',component)

			Reactive Programming:create streams in this,programming paradign that works with data streams
					normally-->create event-->listen-->over
					in reactive programming--->live event
						event wont be completed unless forcefully terminated(unsubscribed)
					Design patterns in reactive programings:
					->Observer Design pattern
					->Iterator deisgn pattern
					->event programing 
					->functional

					observer design pattern-->SW design pattern in which object is called as subject,
						maintain a list of dependents-->called observers
						mainly used to implement distributed event handling in "event driven" software

						React to events-->Event-driven
						React to load-->scalable
						React to failure-->resilient
						React to users-->responsive
						Data streams can be:
							UI Events,HTTp Events,File Systems,Array-like objects,Memory-cache
						Stream:flow of things,A sequence of ongoing events ordered in time
							from streams we can get 3 things:
								1.value
								2.error
								3.success
							ex:->for timing your search,timing API->
							Observables:create observable and then return:
								ways to create observable:
									2 steps to implement reactive programming
										You have a source.ex-:Array,Object,UI,HTTP,FIle System->then attach a listener to 
										Operators
									var foo=Rx.Observable.of(42,100,200);
									stream.subscribe(value=>console.log(value),
										err=>console.log(value),
										completed=>console.log('done'));
									array=>iterate=>filter=>find
									Immutable implementation
									to call subscribe next method is used

									


						




				





				

					